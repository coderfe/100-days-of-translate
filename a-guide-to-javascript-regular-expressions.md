# Javascript 正则表达式指南

> 通过这篇简短的指南，你可以了解所有关于 Javascript 正则表达式的信息，这篇指南总结了最重要的概念，并且用示例展示了这些概念。

<!-- TOC -->

- [Javascript 正则表达式指南](#javascript-正则表达式指南)
  - [正则表达式简介](#正则表达式简介)
  - [很难但很有用](#很难但很有用)
  - [正则表达式看起来是什么样](#正则表达式看起来是什么样)
  - [正则如何工作](#正则如何工作)
  - [（标志位）Anchoring](#标志位anchoring)
  - [范围匹配](#范围匹配)
  - [范围内多次匹配](#范围内多次匹配)
  - [否定模式](#否定模式)
    - [元字符](#元字符)
  - [正则表达式中的或](#正则表达式中的或)

<!-- /TOC -->

## 正则表达式简介

正则表达式（也称之为 regx）是一种高效处理字符串的方法。

通过使用特殊语法构造正则表达式，你可以用来：

- 在字符串中查找文本
- 替换字符串中的子字符串
- 从字符串中提取信息

几乎所有的编程语言都实现了正则表达式。每个实现之间的差异很小，但是一般性概念几乎适用于任何语言。

Regular Expressions date back to the 1950s, when it was formalized as a conceptual search pattern for string processing algorithms.

由于在 UNIX 中（如 grep 和 sed）和受欢迎的编辑器中实现，正则表达式越来越受欢迎，并且被引入到 Perl 编程语言中，随后被引入到更多的编程语言。

Javascript 和 Perl 一样，是支持正则表达式直接内置在该语言中的编程语言之一。

## 很难但很有用

如果没有投入必要的时间去理解它们，正则表达式对于初学者来说简直是一派胡言，而且对于专业的开发人员来讲也经常如此。

神秘的正则表达式很难写、难以理解并且难以维护和修改。

但是有些时候正则是处理一些字符串问题的最明智的方法，因此它是一个非常有价值的工具。

这篇教程的目的在于用一种简单的方式向你介绍 Javascript 的正则表达式，并且提供给你阅读和创造你自己的正则表达式的所有信息。

经验法则是，简单的正则表达式是易写并易读的，而复杂的正则表达式如果不深入掌握基本知识，很快就会变得一团糟。

## 正则表达式看起来是什么样

在 Javascript 中的正则表达式是一个对象，可以用两种方式定义。

第一种是使用构造函数初始化一个新的 RegExp 对象：

```javascript
const re1 = new RegExp('hey');
```

第二种是使用正则表达式的字面量形式：

```javascript
const re2 = /hey/;
```

你知道 Javascript 有对象字面量和数组字面量吗？它也有正则表达式字面量。

在上面的例子中，`hey` 称之为 **模式**。在字面量形式中它由正斜杠分隔，但在构造函数中则不是。

这是两种形式之间第一个重要的区别，但是在稍后我们会看到其他的不同之处。

## 正则如何工作

我们在上面定义的 `re1` 正则表达式非常简单。它会搜索字符串 `hey` ，没有任何限制：字符串可以包含许多文本，`hey` 也在其中，regex 是满足要求的。字符串也可以仅包含 `hey` ，同样也是满足正则匹配的的。

这很简单。

你可以使用 `RexExp.test(String)` 来测试正则表达式，它会返回一个布尔值：

```javascript
re1.test('hey');  // ✅
re1.test('blablabla hey blablabla');  // ✅

re1.test('he');  // ❌
re1.test('blablabla');  //❌
```

在上面的示例中，我们检查了 `hey` 是否满足存储在 `re1` 中的正则表达式模式。

这是它能做的最简单的事儿，但是你已经了解了很多正则表达式的概念。

## （标志位）Anchoring

`/hey/` 匹配字符串任意位置的 `hey` 字符串。

如果你想匹配以 `hey` **开头**的字符串，使用 `^` 操作符：

```javascript
/^hey/.test('hey');  // ✅
/^hey/.test('bla hey');  // ❌
```

如果你想匹配以 `hey` **结尾**的字符串，使用 `$` 操作符：

```javascript
/hey$/.test('hey');  // ✅
/hey$/.test('bla hey');  // ✅
/hey$/.test('hey you');  // ❌
```

结合上面的方法，如果想要完全匹配字符串 `hey` ，仅需要以下代码：

```javascript
/^hey$/.test('hey'); // ✅
```

匹配某个字符串以一个子字符串开头且以另一个子字符串结尾，你可以使用 `.*` ，它用来匹配任意字符不出现或者出现多次。

```javascript
/^hey.*joe$/.test('hey joe');  // ✅
/^hey.*joe$/.test('heyjoe');  // ✅
/^hey.*joe$/.test('hey how are you joe');  // ✅
/^hey.*joe$/.test('hey joe!');  // ❌
```

## 范围匹配

你可以选择在某个范围内匹配任意字符，而不是匹配某个特定的字符串，例如：

```javascript
/[a-z]/  // a, b, c, ..., x, y, z
/[A-Z]/  // A, B, C, ..., X, Y, Z
/[a-c]/  // a, b, c
/[0-8]/  // 0, 1, 2, ..., 7, 8, 9
```

这些正则表达式能过够匹配包含在这些范围内的任意一个字符：

```javascript
/[a-z]/.test('a');  // ✅
/[a-z]/.test('1');  // ❌
/[a-z]/.test('A');  // ❌

/[a-c]/.test('d');  // ❌
/[a-c]/.test('dc');  // ✅
```

范围匹配可以组合起来：

```javascript
/[a-z0-9A-Z]/
```

```javascript
/[A-Za-z0-9]/.test('a');  // ✅
/[A-Za-z0-9]/.test('1');  // ✅
/[A-Za-z0-9]/.test('A');  // ✅
```

## 范围内多次匹配

你可以通过使用 `-` 字符检查一个字符串是否包含一个且仅一个在该范围内的字符：

```javascript
/[^a-zA-z0-9]$/

/[^a-zA-z0-9]$/.test('A');  // ✅
/[^a-zA-z0-9]$/.test('Ab');  // ❌
```

## 否定模式

The ^ character at the beginning of a pattern anchors it to the beginning of a string.

在范围匹配中使用 `^` 会否定正则表达式，像这样：

```javascript
/[^A-Za-z0-9]/.test('a'); // ❌
/[^A-Za-z0-9]/.test('A'); // ❌
/[^A-Za-z0-9]/.test('1'); // ❌
/[^A-Za-z0-9]/.test('@'); // ✅
```

### 元字符

- `\d` 匹配任何数字，等价于 `[0-9]`
- `\D` 匹配任何非数字，等价于 `[^0-9]`
- `\w` 匹配任何字母或数字，等价于 `[A-Za-z0-9]`
- `\W` 匹配任何非字母或数字，等价于 `[^A-Za-z0-9]`
- `\s` 匹配任何空白字符：空格、制表符、换行及 Unicode 空白
- `\S` 匹配非空白字符
- `\0` 匹配 null
- `\n` 匹配换行符
- `\t` 匹配制表符
- `\uXXXX` 匹配 [unicode](https://flaviocopes.com/unicode/) 字符（需要 `u` 标识）
- `.` 匹配非换行符（例如 `\n`）的任意字符（除非你使用 `n` 标志，稍后将谈到它）。
- `[^]` 匹配任意字符，包括换行符。在多行文本中非常有用。

## 正则表达式中的或
